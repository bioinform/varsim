package com.bina.varsim.tools.evaluation;

import com.bina.varsim.VarSimTool;
import com.bina.varsim.VarSimToolNamespace;
import com.bina.varsim.constants.Constant;
import com.bina.intervalTree.SimpleInterval1D;
import com.bina.intervalTree.ValueInterval1D;
import com.bina.varsim.types.*;
import com.bina.varsim.types.constraint.UnsatisfiedConstraintException;
import com.bina.varsim.types.stats.EnumStatsRatioCounter;
import com.bina.varsim.types.stats.StatsNamespace;
import com.bina.varsim.types.variant.Variant;
import com.bina.varsim.types.variant.VariantOverallType;
import com.bina.varsim.types.variant.VariantType;
import com.bina.varsim.types.variant.alt.Alt;
import com.bina.varsim.util.ConstraintValidator;
import com.bina.varsim.util.SimpleReference;
import com.bina.varsim.util.VCFparser;
import com.bina.varsim.util.chrSearchTree;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.io.FileUtils;
import org.apache.log4j.Logger;
import org.jgrapht.Graph;
import org.jgrapht.graph.SimpleWeightedGraph;
import org.jgrapht.graph.builder.UndirectedWeightedGraphBuilderBase;
import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;

import static com.bina.varsim.types.ComparisonResultWriter.*;


/**
 * Compare two VCF files, output the TPR and FDR for various bins and variant types
 * <p>
 * TODO: this file needs massive refactoring
 *
 * @author johnmu
 */

// TODO this class does not yet compare the contents of the larger variants
    //TODO refactor variable naming
public class VCFcompare extends VarSimTool {
    static final double OVERLAP_ARG = 0.8;
    static final int WIGGLE_ARG = 20;
    static final byte[] ambiguousBase = "N".getBytes();
    private static final Set<FlexSeq.Type> canonicalizableFlexSeqTypes = EnumSet.of(FlexSeq.Type.SEQ, FlexSeq.Type.TRA_DUP, FlexSeq.Type.ISP_DUP, FlexSeq.Type.TRA_DEL);
    private final static Logger log = Logger.getLogger(VCFcompare.class.getName());

    @Option(name = "-reference", usage = "Reference Genome, specificity will be computed if provided", metaVar = "file")
    String reference;

    @Option(name = "-true_vcf", usage = "Truth VCF file generated by VarSim [Required]", metaVar = "file", required = true)
    String trueVcfFilename;

    @Argument(usage = "One or more VCF files from secondary analysis", metaVar = "vcf_files ...", required = true)
    ArrayList<String> newVcfFilename;

    @Option(name = "-prefix", usage = "Prefix for output file [Required]", metaVar = "file", required = true)
    String outPrefix;

    @Option(name = "-over", usage = "Reciprocal overlap ratio allowance in validation [" + OVERLAP_ARG + "]")
    double overlapRatio = OVERLAP_ARG;

    @Option(name = "-wig", usage = "Wiggle allowance in validation [" + WIGGLE_ARG + "]")
    int wiggle = WIGGLE_ARG;

    @Option(name = "-ignore_ins_len", usage = "Ignores insertion length when comparing")
    boolean ignoreInsertionLength = false;

    @Option(name = "-match_geno", usage = "Also ensures genotypes match")
    boolean matchGenotype = false;

    @Option(name = "-output_distance_metric", usage = "output distance-based metrics," +
            " if enabled, truth and test variants will be matched globally rather than locally.")
    boolean outputDistanceMetric = false;

    @Option(name = "-bed", usage = "BED file to restrict the analysis [Optional]", metaVar = "BED_file")
    String bedFilename = "";

    @Option(name = "-bed_exclude_tpr", usage = "Exclude TPR from the BED file filtering")
    boolean excludeTprFromBedFiltering;

    @Option(name = "-bed_exclude_fdr", usage = "Exclude FDR from the BED file filtering")
    boolean excludeFdfFromBedFiltering;

    @Option(name = "-bed_either", usage = "Use either break-end of the variant for filtering instead of both")
    boolean bedEither;

    @Option(name = "-html", usage = "Insert JSON to HTML file [Optional, internal]", metaVar = "HTML_file", hidden = true)
    File htmlFile = null;

    @Option(name = "-sample", usage = "Sample to read from new VCF, otherwise will read first one [Optional]", metaVar = "String")
    String sampleName = null;

    @Option(name = "-exclude_filtered", usage = "Exclude filtered variants. Will only load variants with '.' or 'PASS' in the FILTER column")
    boolean excludeFiltered = false;

    @Option(name = "-include_chr", usage = "Comma separated list of chromosomes to include, default is include all", metaVar = "CHR_LIST")
    String chromosomeToBeIncluded = null;

    @Option(name = "-con", usage = "One or more constraints on the accuracy of the output", metaVar = "CONSTRAINT")
    List<String> constraintArgs = null;

    public VCFcompare(final String command, final String description) {
        super(command, description);
    }

    public static void main(String[] args) {
        new VCFcompare("", VarSimToolNamespace.VCFCompare.description).run(args);
    }

    /**
     * canonicalize to indels
     * @param canonicalVariantList where results are saved
     * @param alleleLengthDifference
     * @param reference
     * @param alternativeAlleles
     * @param variant
     * @param currentPosition
     * @param end should we append indels to the end?
      */
    private void canonicalizeToIndels(List<Variant> canonicalVariantList, int[] alleleLengthDifference, byte[] reference, byte[][] alternativeAlleles,
                                      Variant variant, int currentPosition, boolean end) {
        Variant.Builder template = new Variant.Builder().chr(variant.getChr()).isPhased(true).
                varId(variant.getVariantId()).filter(VCFparser.DEFAULT_FILTER).refDeleted("");
        // add insertions or deletions for complex variants
        if (alleleLengthDifference[0] == alleleLengthDifference[1] && alleleLengthDifference[0] != 0) {
            // homozygous
            if (alleleLengthDifference[0] > 0) {
                // insertion
                if (Arrays.equals(alternativeAlleles[0], alternativeAlleles[1])) {
                    byte[] phase = {1, 1};

                    if (end) {
                        Alt alt = new Alt();
                        alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0], 0, alleleLengthDifference[0])));
                        canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).
                                ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
                    } else {
                        Alt alt = new Alt();
                        alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0], 0, alleleLengthDifference[0])));
                        canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).
                                ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
                    }
                } else {
                    byte[] phase = {0, 0};
                    if (end) {
                        phase[0] = 1;
                        phase[1] = 0;
                        Alt alt = new Alt();
                        alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0], 0, alleleLengthDifference[0])));
                        canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).
                                ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
                        phase[0] = 0;
                        phase[1] = 1;
                        Alt alt2 = new Alt();
                        alt2.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[1], 0, alleleLengthDifference[1])));
                        canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).
                                ref(new byte[0]).alts(new Alt[]{alt2}).phase(phase).build());
                    } else {
                        phase[0] = 1;
                        phase[1] = 0;
                        Alt alt = new Alt();
                        alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0], 0, alleleLengthDifference[0])));
                        canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).
                                ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
                        phase[0] = 0;
                        phase[1] = 1;
                        Alt alt2 = new Alt();
                        alt2.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[1], 0, alleleLengthDifference[1])));
                        canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).
                                ref(new byte[0]).alts(new Alt[]{alt2}).phase(phase).build());
                    }
                }
            } else if (alleleLengthDifference[0] < 0) {
                //here both alternative alleles are shorter than the reference allele
                // deletion
                byte[] phase = {1, 1};
                //VarSim will try adding indels both to left end and to right end
                if (end) {
                    Alt alt = new Alt();
                    alt.setSeq(new FlexSeq());
                    canonicalVariantList.add(template.pos(currentPosition + alternativeAlleles[0].length).
                            referenceAlleleLength(-alleleLengthDifference[0]).
                            ref(Arrays.copyOfRange(reference, alternativeAlleles[0].length, alternativeAlleles[0].length - alleleLengthDifference[0])).
                            alts(new Alt[]{alt}).phase(phase).build());
                } else {
                    Alt alt = new Alt();
                    alt.setSeq(new FlexSeq());
                    canonicalVariantList.add(template.pos(currentPosition).
                            referenceAlleleLength(-alleleLengthDifference[0]).
                            ref(Arrays.copyOfRange(reference, 0, -alleleLengthDifference[0])).
                            alts(new Alt[]{alt}).phase(phase).build());
                }
            }
        } else {
            for (int a = 0; a < alternativeAlleles.length; a++) {
                if (alleleLengthDifference[a] > 0) {
                    // insertion
                    byte[] phase = {0, 0};
                    phase[a] = 1;
                    if (end) {
                        Alt alt = new Alt();
                        alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[a], 0, alleleLengthDifference[a])));
                        canonicalVariantList.add(template.pos(currentPosition + reference.length).
                                referenceAlleleLength(0).ref(new byte[0]).
                                alts(new Alt[]{alt}).phase(phase).build());
                    } else {
                        Alt alt = new Alt();
                        alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[a], 0, alleleLengthDifference[a])));
                        canonicalVariantList.add(template.pos(currentPosition).
                                referenceAlleleLength(0).ref(new byte[0]).
                                alts(new Alt[]{alt}).phase(phase).build());

                    }
                } else if (alleleLengthDifference[a] < 0) {
                    // deletion
                    byte[] phase = {0, 0};
                    phase[a] = 1;
                    if (end) {
                        Alt alt = new Alt();
                        alt.setSeq(new FlexSeq());
                        canonicalVariantList.add(template.pos(currentPosition + alternativeAlleles[a].length).
                                referenceAlleleLength(-alleleLengthDifference[a]).
                                ref(Arrays.copyOfRange(reference, alternativeAlleles[a].length, alternativeAlleles[a].length - alleleLengthDifference[a])).
                                alts(new Alt[]{alt}).phase(phase).build());
                    } else {
                        Alt alt = new Alt();
                        alt.setSeq(new FlexSeq());
                        canonicalVariantList.add(template.pos(currentPosition).
                                referenceAlleleLength(-alleleLengthDifference[a]).
                                ref(Arrays.copyOfRange(reference, 0, -alleleLengthDifference[a])).
                                alts(new Alt[]{alt}).phase(phase).build());
                    }
                }
            }
        }
    }

    /**
     * wrapper for variant canonicalization (conversion to indels + SNPs)
     * VarSim will convert regular variants into normalized variants, i.e. insertion,deletion
     * plus SNPs. It will try placing insertions and deletions at both beginning and end of
     * a variant and pick the placement with fewest # of mismatches (normalized variants).
     *
     * @param var
     * @return
     */
    private List<Variant> canonicalizeVariant(Variant var) {
      /*
      why do we need to create a copy of variant?
      because we will set it to reference allele
      after canonicalization.
       */
        //not adding indels to the end
        List<Variant> variantList = canonicalizeVariant(new Variant(var), false);
        //try adding indels to the end
        List<Variant> variantListEnd = canonicalizeVariant(new Variant(var), true);
        if (variantListEnd.size() < variantList.size()) {
            variantList = variantListEnd;
        }
        return variantList;
    }

    /**
     * actual implementation for canonicalization
     * @param variant
     * @param end
     * @return
     */
    //if end = true, we add indels to the end
    private List<Variant> canonicalizeVariant(Variant variant, boolean end) {
        List<Variant> variantList = new ArrayList<>();

        // if the variant is an MNP or SNP, break it dooooownnn

        boolean noSplit = false;
        if (variant.getType() == VariantOverallType.SNP) {
            noSplit = true;
        }
        //both alleles are reference alleles
        if (variant.getCompositions() == null && variant.getGoodPaternal() == 0 && variant.getGoodMaternal() == 0) {
            noSplit = true;
        }
        //paternal allele is not reference or sequence
        if (variant.getGoodPaternal() != 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodPaternal()).getSeqType())) {
            noSplit = true;
        }
        //maternal allele is not reference or sequence
        if (variant.getGoodMaternal() != 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodMaternal()).getSeqType())) {
            noSplit = true;
        }
        //paternal allele is not reference and has zero-length allele and reference sequence
        if (variant.getGoodPaternal() != 0 && variant.getAlt(variant.getGoodPaternal()).length() == 0 && variant.getReference().length == 0) {
            noSplit = true;
        }
        //maternal allele is not reference and has zero-length allele and reference sequence
        if (variant.getGoodMaternal() > 0 && variant.getAlt(variant.getGoodMaternal()).length() == 0 && variant.getReference().length == 0) {
            noSplit = true;
        }

        if (noSplit) {
            variantList.add(variant);
            return variantList;
        }

        if (variant.getCompositions() != null) {
            for (Variant c : variant.getCompositions()) {
                variantList.addAll(canonicalizeVariant(new Variant(c), end));
            }
            return variantList;
        }

        /*
        split long variants into small ones for unambiguous comparison
        or into breakends

        it feels like when we canonicalize variants, we treat all variants
        as if they were pahsed, and then during comparison, we ignore
        phasing information if not required to consider it.

         */
        Variant.Builder template = new Variant.Builder().chr(variant.getChr()).
                isPhased(true).varId(variant.getVariantId()).filter(VCFparser.DEFAULT_FILTER).refDeleted("");

        if ( variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Duplication ||
                variant.getType(variant.getGoodMaternal()) == VariantType.Interspersed_Duplication ||
                    variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Duplication ||
                    variant.getType(variant.getGoodPaternal()) == VariantType.Interspersed_Duplication) {

            for (int parentIndex = 0; parentIndex < 2; parentIndex++) {
                int allele = variant.getAllele(parentIndex);
                if (variant.getType(allele) == VariantType.Reference)
                    continue;
                byte[] phase = new byte[2];
                phase[parentIndex] = 1;
                if (variant.getType(allele) == VariantType.Translocation_Duplication ||
                        variant.getType(allele) == VariantType.Interspersed_Duplication) {
                    /* an example
                    >1
                    12345678-901-2
                    AATCATCG-TGG-C
                    >2
                    123456-7890-1234567
                    TTCGTT-ATTA-CCCCAAA

                    1	8	.	G	<DUP:TRA>	.	PASS	SVTYPE=DUP;SVLEN=4;END=11;CHR2=2;POS2=7;END2=10	GT	1|1
                    ||
                    \/
                    #left-left, left breakend of the left adjacency
                    1 8 . G G[2:7[
                    #left-right
                    2 7 . A ]1:8]A
                    #right-left
                    2 10 . A A[1:12[
                    #right-right
                    1 12 . C ]2:10]C

                    note here, half of the information is redundant, so we do not need to
                    save and compare all 4 breakends, we only need to compare half of them.
                    and during comparison, we compare both POS and ALT parts.
                     */
                    boolean isInversed = variant.isInversed();
                    //we got two new adjacencies here, represented by 4 breakends
                    //left-left
                    Alt alt1 = new Alt();
                    alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(), variant.getChr2(allele),
                            isInversed ? variant.getEnd2(allele) : variant.getPos2(allele), true, !isInversed));
                    /*
                    ******************
                    why pos-1? because VarSim will shift the start position to the right to mark the 1-based start of a variant
                    however, here for a breakend, we need to shift it back
                    ******************
                    */
                    variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).
                            ref(new byte[0]).alts(new Alt[]{alt1}).phase(phase).build());

                    //right-right
                    Alt alt2 = new Alt();
                    alt2.setBreakend(new Alt.Breakend(ambiguousBase, variant.getChr2(parentIndex),
                            isInversed ? variant.getPos2(parentIndex) : variant.getEnd2(parentIndex), false, isInversed));
                    //here we assume the reference allele length = 1, i.e. the reference base before the breakpoint (before shifting during vcf parsing)
                    //after the shifting in vcf parsing, pos points to the base after breakpoint
                    variantList.add(template.pos(variant.getPos()).
                            referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt2}).phase(phase).build());
                }
                //a translocation consists of a duplication and a deletion, we only decompose the duplication into breakends
                //the deletion will be delt with as other variant types (type match + interval overlap)
                variant.setAllele(parentIndex, (byte) 0); // set to reference
            }
        } else if ( variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Deletion ||
                variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Deletion) {

            for (int parentIndex = 0; parentIndex < 2; parentIndex++) {
                int allele = variant.getAllele(parentIndex);
                if (variant.getType(allele) == VariantType.Reference)
                    continue;
                byte[] phase = new byte[2];
                phase[parentIndex] = 1;
                if (variant.getType(allele) == VariantType.Translocation_Deletion) {
                    /* an example
                    >1
                    12345678-901-2
                    AATCATCG-TGG-C
                    >2
                    123456-7890-1234567
                    TTCGTT-ATTA-CCCCAAA

                    2 6 . T <DEL:TRA> . PASS  SVTYPE=DEL;SVLEN=-4 GT 1|1
                    ||
                    \/
                    #left
                    1 6 . T T[2:11[
                    #right
                    1 11 . C ]1:6]C

                    note here, half of the information is redundant, so we do not need to
                    save and compare both breakends, we only need to compare half of them.
                    and during comparison, we compare both POS and ALT parts.
                     */
                    //we got two new adjacencies here, represented by 2 breakends
                    //left
                    Alt alt1 = new Alt();
                    alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(), variant.getChr(),
                            variant.getPos() + variant.getReferenceAlleleLength(), true, true));
                    /*
                    ******************
                    why pos-1? because VarSim will shift the start position to the right to mark the 1-based start of a variant
                    however, here for a breakend, we need to shift it back
                    ******************
                    */
                    variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).
                            ref(new byte[0]).alts(new Alt[]{alt1}).phase(phase).build());
                }
                //a translocation consists of a duplication and a deletion, we only decompose the duplication into breakends
                //the deletion will be delt with as other variant types (type match + interval overlap)
                variant.setAllele(parentIndex, (byte) 0); // set to reference
            }
        } else if (variant.getType(variant.getGoodPaternal()) != VariantType.Reference
                && variant.getType(variant.getGoodMaternal()) != VariantType.Reference) {
            //neither of paternal and maternal alleles are reference alleles

            //0 for reference, 1 for 1st alt allele, 2 for 2nd alt allele
            int[] alleleNumber = {variant.getAllele(0), variant.getAllele(1)};
            byte[][] alternativeAlleleSequence = {variant.getAlt(alleleNumber[0]).getSequence(), variant.getAlt(alleleNumber[1]).getSequence()};
            byte[] referenceAlleleSequence = variant.getReference();
            int currentPosition = variant.getPos();

            // modify positions based on if ref matches alt
            int minMatchLength = variant.getMinMatchLength();

            /*
            reference   ******|------
            paternal    ******|--
            maternal    ******|------

            we will right-shift the variant to remove redundancy with the reference
            */
            if (minMatchLength > 0) {
                //remove redundancy in reference
                referenceAlleleSequence = Arrays.copyOfRange(referenceAlleleSequence, minMatchLength, referenceAlleleSequence.length);
                //remove redundancy in alternative alleles
                for (int i = 0; i < 2; i++) {
                    alternativeAlleleSequence[i] = Arrays.copyOfRange(alternativeAlleleSequence[i], minMatchLength, alternativeAlleleSequence[i].length);
                }
                currentPosition += minMatchLength;
            }

            //length difference between reference and allele
            int[] alleleLengthDifference = {alternativeAlleleSequence[0].length - referenceAlleleSequence.length,
                                            alternativeAlleleSequence[1].length - referenceAlleleSequence.length};

            /*
            convert the variant into insertion/deletion + SNPs
             */
            canonicalizeToIndels(variantList, alleleLengthDifference, referenceAlleleSequence, alternativeAlleleSequence, variant, currentPosition, end);

          /*
          iterate over reference bp, note here the reference has been adjusted to
          remove redudancy. Create SNPs (for canonicalization) wherever there are
          mismatches.
           */
            for (int relativePosition = 0; relativePosition < referenceAlleleSequence.length; relativePosition++, currentPosition++) {

                //relative position on alleles (adjusted for insertions/deletions)
                int[] alleleSpecificRelativePosition = new int[2];
                if (end) {
                    //TODO: there are many places a for loop over 0,1 is used to iterate over all genotypes, maybe it's better to use an immutable data structure
                    for (int j = 0; j < 2; j++) {
                      //recall: diff[j] = alt[j].length - ref.length
                        if (relativePosition < referenceAlleleSequence.length + alleleLengthDifference[j]) {
                            alleleSpecificRelativePosition[j] = relativePosition;
                        } else {
                            alleleSpecificRelativePosition[j] = -1; // we are into deleted bases
                        }
                    }
                } else {
                    for (int j = 0; j < 2; j++) {
                        //this one dictates that canonicalized variants will be located on the right end of reference allele
                        alleleSpecificRelativePosition[j] = relativePosition + alleleLengthDifference[j];
                    }
                }

                if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] < 0) {
                    // both deleted
                    /*
                    AGG
                    --G
                    --G
                    ^    the scenario this if statement deals with
                     */
                } else if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 &&
                           alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition]) {
                    /* one deleted, hence the other is homozygous
                    e.g. ref: AGG, alts: C,CT
                    if we visualize the alignment, it looks like
                    AGG
                    -CT
                    --C
                     ^  the scenario this if statement deals with
                    */
                    byte[] phase = {1, 1};
                    Alt alt = new Alt();
                    alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
                    variantList.add(template.pos(currentPosition).referenceAlleleLength(1).
                            ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
                } else if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 &&
                        alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
                    // one deleted, hence the other is homozygous
                    //same as above but two alleles switch
                    byte[] phase = {1, 1};
                    Alt alt = new Alt();
                    alt.setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
                    variantList.add(template.pos(currentPosition).referenceAlleleLength(1).
                            ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
                } else if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 &&
                           alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition]) {
                    // ref call with del
                  /*
                    AGG
                    -GT
                    --C
                     ^  the scenario this if statement deals with
                    */
                } else if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 &&
                        alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
                    // ref call with del
                  //same as above but switch alleles
                } else if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition] &&
                        alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
                    // ref call
                  /*
                    AGG
                    -GG
                    --G
                      ^  the scenario this if statement deals with
                    */
                } else if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]) {
                    // homozygous non-reference alleles
                  /*
                    AGG
                    -GC
                    --C
                      ^  the scenario this if statement deals with
                    */
                    byte[] phase = {1, 1};
                    Alt alt = new Alt();
                    alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
                    variantList.add(template.pos(currentPosition).referenceAlleleLength(1).
                            ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
                } else if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition] &&
                        alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
                    // het but both alt
                  /*
                    AGG
                    -GC
                    --T
                      ^  the scenario this if statement deals with
                    */
                    byte[] phase = {1, 2};
                    Alt[] alts = new Alt[2];
                    alts[0] = new Alt();
                    alts[1] = new Alt();
                    alts[0].setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
                    alts[1].setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
                    variantList.add(template.pos(currentPosition).referenceAlleleLength(1).
                            ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(alts).phase(phase).build());
                } else {
                    // het with one ref
                  /*
                    AGG
                    -GG
                    --T
                      ^  the scenario this if statement deals with
                    */
                    for (int a = 0; a < 2; a++) {
                        if (alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]] != referenceAlleleSequence[relativePosition]) {
                            byte[] phase = {0, 0};
                            phase[a] = 1;
                            Alt alt = new Alt();
                            alt.setSeq(new FlexSeq(alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]]));
                            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).
                                    ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
                        }
                    }
                }

            }
            variant.setAllele(0, (byte) 0); // set to reference
            variant.setAllele(1, (byte) 0); // set to reference
        } else {
            //at least one of paternal and maternal alleles is reference
            for (int alleleIndex = 0; alleleIndex < 2; alleleIndex++) {
                int allele = variant.getAllele(alleleIndex);
                //only process Complex, MNP and SNP variants
                if (variant.getType(allele) == VariantType.Complex
                        || variant.getType(allele) == VariantType.MNP
                        || variant.getType(allele) == VariantType.SNP) {
                    byte[] alternativeAlleleSequence = variant.getAlt(allele).getSequence();
                    byte[] referenceSequence = variant.getReference();
                    int currentPosition = variant.getPos();
                    int alleleLengthDifference = alternativeAlleleSequence.length - referenceSequence.length;

                    // add insertions or deletions for complex variants

                    if (alleleLengthDifference > 0) {
                        // insertion
                        byte[] phase = {0, 0};
                        phase[alleleIndex] = 1;
                        if (end) {
                            Alt alt = new Alt();
                            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence, 0, alleleLengthDifference)));
                            variantList.add(template.pos(currentPosition + referenceSequence.length).referenceAlleleLength(0).
                                    ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
                        } else {
                            Alt alt = new Alt();
                            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence, 0, alleleLengthDifference)));
                            variantList.add(template.pos(currentPosition).referenceAlleleLength(0).
                                    ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
                        }
                    } else if (alleleLengthDifference < 0) {
                        // deletion
                        byte[] phase = {0, 0};
                        phase[alleleIndex] = 1;
                        if (end) {
                            Alt alt = new Alt();
                            alt.setSeq(new FlexSeq());
                            variantList.add(template.pos(currentPosition + alternativeAlleleSequence.length).
                                    referenceAlleleLength(-alleleLengthDifference).
                                    ref(Arrays.copyOfRange(referenceSequence, alternativeAlleleSequence.length, alternativeAlleleSequence.length - alleleLengthDifference)).
                                    alts(new Alt[]{alt}).phase(phase).build());
                        } else {
                            Alt alt = new Alt();
                            alt.setSeq(new FlexSeq());
                            variantList.add(template.pos(currentPosition).
                                    referenceAlleleLength(-alleleLengthDifference).
                                    ref(Arrays.copyOfRange(referenceSequence, 0, -alleleLengthDifference)).
                                    alts(new Alt[]{alt}).phase(phase).build());
                        }
                    }

                    for (int i = 0; i < referenceSequence.length; i++) {
                        int idx;
                        if (end) {
                            if (i < referenceSequence.length + alleleLengthDifference) {
                                idx = i;
                            } else {
                                idx = -1; // we are in a deleted region
                            }
                        } else {
                            idx = i + alleleLengthDifference;
                        }

                        if (idx >= 0 && alternativeAlleleSequence[idx] != referenceSequence[i]) {
                            byte[] phase = {0, 0};
                            phase[alleleIndex] = 1;

                            Alt alt = new Alt();
                            alt.setSeq(new FlexSeq(alternativeAlleleSequence[idx]));
                            variantList.add(template.pos(currentPosition).
                                    referenceAlleleLength(1).ref(new byte[]{referenceSequence[i]}).
                                    alts(new Alt[]{alt}).phase(phase).build());
                        }

                        currentPosition++;
                    }

                    variant.setAllele(alleleIndex, (byte) 0); // set to reference
                }
            }
        }

        if (!variant.isRef()) {
            variantList.add(variant);
        }

        return variantList;
    }

    /**
     * Main method
     * first put all true variants into chromosome-indexed interval tree
     * then scan all comparison variants to find overlaps
     *
     */
    public void run(String[] args) {
        if (!parseArguments(args)) {
            return;
        }
        if (outputDistanceMetric) {
            globalMatching();
        } else {
            localMatching();
        }
    }

    /**
     * match truth and test variants on a local basis, i.e.
     * do not optimize matching to reduce global mismatches
     *
     * this is for preserving legacy behavior
     */
    private void localMatching() {

        // these are the statistics we "ideally" want to collect
        // number of variants correct (either genotype) (for each type)
        // number homozygous correct (for each type)
        // number heterozygous correct (for each type)
        // number homozygous genotype correct (for each type)
        // number heterozyous genotype correct (for each type)


        BedFile intersector = null;
        boolean bedExists = false;
        // check if the file exists
        try {
            File f = new File(bedFilename);
            bedExists = f.exists();
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (bedExists) {
            log.info("Using " + bedFilename + " to intersect");
            intersector = new BedFile(bedFilename);
        } else {
            if (excludeTprFromBedFiltering || excludeFdfFromBedFiltering) {
                log.warn("No BED file specified but used exclude parameters");
            }
        }

        Set<String> chrAcceptor = null;
        //TODO: make chrAcceptor a class
        if (chromosomeToBeIncluded != null) {
            chrAcceptor = new HashSet<>(Arrays.asList(chromosomeToBeIncluded.split(",")));
            log.info("Only accepting chromosomes: " + Arrays.toString(chrAcceptor.toArray()));
        }

        ConstraintValidator validator = new ConstraintValidator(constraintArgs);

        // Load refernece genome
        SimpleReference referenceGenome = reference == null ? null : new SimpleReference(reference);

        // load true VCF into interval tree
        log.info("Load Truth VCF");

        outputClass outputBlob = new outputClass();

        outputBlob.setParams(new CompareParams());
        outputBlob.getParams().setBedFilename(bedFilename);
        // TODO: make it output the full list if variants in JSON
        outputBlob.getParams().setNewVcfFilename(newVcfFilename.get(0));
        outputBlob.getParams().setOverlapPercent(overlapRatio);
        outputBlob.getParams().setTrueVcfFilename(trueVcfFilename);
        outputBlob.getParams().setWiggle(wiggle);

        VCFparser trueVcfParser = new VCFparser(trueVcfFilename, null, false);

        // allow duplicates, this is needed because insertions don't actually take up a location
        chrSearchTree<ValueInterval1D<Variant>> trueVariantIntervalTree = new chrSearchTree<>(true);
        int numReadOriginalVariant = 0;
        int numAddedSplitVariant = 0;


        //track TRAID-linked variants
        Map<String, List<Variant>> traid2composingVariants = new HashMap<>();

        // this is for the original variants
        // it stores the total length of the original variant in bases
        // Still check for validation of canonical full variants
        ArrayList<Integer> validatedTotalLength = new ArrayList<>();
        ArrayList<Variant> trueVariantsForOutput = new ArrayList<>();

        // For each true variant, if the number of bases validated is over a certain threshold
        // call it correct
        outputBlob.setNumberOfTrueCorrect(new EnumStatsRatioCounter<VariantOverallType>());

        // For called variants, break down into canonical ones and count based on that
        // if any called variant overlaps a complex variant or MNP, count it as "complex"
        // otherwise, simple count them in their canonical forms

        // store true variants as canonical ones, but remember original form
        while (trueVcfParser.hasMoreInput()) {
            Variant trueVariant = trueVcfParser.parseLine();
            if (trueVariant == null ||
                (!trueVariant.getGenotypes().isNonRef()) ||
                (chrAcceptor != null && !chrAcceptor.contains(trueVariant.getChr().getName()))) {
                log.info("skip line");
                continue;
            }

            VariantOverallType trueVariantOriginalType = trueVariant.getType();

            if (trueVariant.getTraid() != null) {
                String currentTraid = trueVariant.getTraid();
                if (traid2composingVariants.containsKey(currentTraid)) {
                    traid2composingVariants.get(currentTraid).add(trueVariant);
                    trueVariant = new Variant.Builder().compositions(traid2composingVariants.get(currentTraid)).build();
                    traid2composingVariants.remove(currentTraid);
                } else {
                    traid2composingVariants.put(currentTraid, new ArrayList<Variant>());
                    traid2composingVariants.get(currentTraid).add(trueVariant);
                    continue;
                }
            }
            // determine max variant region
            // when comparing genotypes, we need to individually compare
            // to make sure they really overlap

            //TODO: remove constructor here (because another copy will be created inside canonicalizeVariant
            List<Variant> canonicalVariantList = canonicalizeVariant(new Variant(trueVariant));

            int totalLength = canonicalVariantList.stream().mapToInt(v -> v.maxLen()).sum();
            int maxLength = canonicalVariantList.stream().mapToInt(v -> v.maxLen()).max().getAsInt();

            // add to interval tree
            for (Variant currentVariant : canonicalVariantList) {

                ChrString chr = currentVariant.getChr();
                SimpleInterval1D currentVariantInterval = null;
                try {
                    currentVariantInterval = currentVariant.getGenotypeUnionVariantInterval();
                } catch (Exception e) {
                    e.printStackTrace();
                    log.error("Original variant: " + trueVariant);
                    log.error("Bad variant: " + currentVariant);
                    System.exit(1);
                }
                currentVariant.splitVariantIndex = numAddedSplitVariant;
                currentVariant.wholeVariantIndex = numReadOriginalVariant;
                currentVariant.originalType = trueVariantOriginalType;

                trueVariantIntervalTree.put(chr, new ValueInterval1D<>(currentVariantInterval, currentVariant));
                numAddedSplitVariant++;
            }

            if (totalLength >= Constant.SVLEN && maxLength >= overlapRatio * totalLength && canonicalVariantList.size() > 1) {
                // in this case we break down the variant into canoical forms since
                // the original variant was probably a large deletion with a small insertion
                for (Variant currentVariant : canonicalVariantList) {
                    int currentLength = currentVariant.maxLen();
                    validatedTotalLength.add(currentLength);
                    trueVariantsForOutput.add(currentVariant);
                    numReadOriginalVariant++;
                }
            } else {
                validatedTotalLength.add(totalLength);
                trueVariantsForOutput.add(trueVariant);
                numReadOriginalVariant++;
            }
        }

        log.info("Num read:  " + numReadOriginalVariant);
        log.info("Num added: " + numAddedSplitVariant);
        log.info("Num nodes: " + trueVariantIntervalTree.size());
        log.info("Max depth: " + trueVariantIntervalTree.maxDepth());

        // this is for the split variants
        // set to true if the canonical original variant was validated true
        BitSet validatedTrue = new BitSet(numAddedSplitVariant);

        // this is for the original variants
        // count of the number of bases validated for the original variant
        int[] fullValidatedCount = new int[numReadOriginalVariant];

        // generate the output files
        try (
            PrintWriter tpWriter = TP_WRITER.getWriter(outPrefix);
            PrintWriter unknownTpWriter = UNKNOWN_TP_WRITER.getWriter(outPrefix);
            PrintWriter fpWriter = FP_WRITER.getWriter(outPrefix);
            PrintWriter unknownFpWriter = UNKNOWN_FP_WRITER.getWriter(outPrefix);
            PrintWriter fnWriter = FN_WRITER.getWriter(outPrefix);
            PrintWriter jsonWriter = JSON_WRITER.getWriter(outPrefix);) {


        // for this case we add to false positives if the variant is not validated.
        // However, do don't add to true positives, those that computed later

        log.info("Load New VCF");
        int numberOfNewVariants = 0;
        // iterate over new VCF and collect stats

        traid2composingVariants.clear();

        for (String currentVcfFile : newVcfFilename) {
            VCFparser newParser = new VCFparser(currentVcfFile, sampleName, excludeFiltered);

            while (newParser.hasMoreInput()) {
                Variant variant = newParser.parseLine();

                //TODO: wrap variant comparison into a method for easier reading
                if (variant == null ||
                   (chrAcceptor != null && !chrAcceptor.contains(variant.getChr().getName()))) {
                    log.info("skip line");
                    continue;
                }

                boolean skipFP = false;

                if (variant.getTraid() != null) {
                    String currentTraid = variant.getTraid();
                    if (traid2composingVariants.containsKey(currentTraid)) {
                        traid2composingVariants.get(currentTraid).add(variant);
                        variant = new Variant.Builder().compositions(traid2composingVariants.get(currentTraid)).build();
                        traid2composingVariants.remove(currentTraid);
                        if (intersector != null) {
                          for (Variant c : variant.getCompositions()) {
                              if (!excludeFdfFromBedFiltering && !intersector.containsEndpoints(c.getChr(), c.getGenotypeUnionAlternativeInterval(), bedEither)) {
                                  skipFP = true;
                              }
                          }
                        }
                    } else {
                        traid2composingVariants.put(currentTraid, new ArrayList<Variant>());
                        traid2composingVariants.get(currentTraid).add(variant);
                        continue;
                    }
                } else {
                    if (intersector != null) {
                        if (!excludeFdfFromBedFiltering && !intersector.containsEndpoints(variant.getChr(), variant.getGenotypeUnionAlternativeInterval(), bedEither)) {
                            skipFP = true;
                        }
                    }
                }

                // the overall type of the called variant
                VariantOverallType currentVariantType = variant.getType();

                // if called as complex variant convert to indel+snps
                List<Variant> canonicalVariantList = canonicalizeVariant(variant);

                int totalLength = canonicalVariantList.stream().mapToInt(v -> v.maxLen()).sum();
                double validatedLength = 0;
                int maxLength = canonicalVariantList.stream().mapToInt(v -> v.maxLen()).max().getAsInt();

                // split up variants that are basically one big variant and one small one
                //maxLength / totalLength >= overlapRatio, true if the longest canonicalized variant
                //is longer than certain proportion of sum of lengths of all canonicalized variants.
                boolean computeAsSplit = totalLength >= Constant.SVLEN && maxLength >= overlapRatio * totalLength  &&
                    canonicalVariantList.size() > 1;

                for (Variant currentVariant : canonicalVariantList) {
                    // get genotype
                    Genotypes geno = currentVariant.getGenotypes();
                    //note here ResultComparator is created for each canonical variant
                    ResultComparator resultComparator = new ResultComparator(trueVariantIntervalTree, overlapRatio, wiggle, ignoreInsertionLength);

                    if (currentVariant.isHom()) {
                        int maxTrueLength = resultComparator.compareVariant(currentVariant, geno.geno[0], validatedTrue);
                        final DualIdx dualIdx = matchGenotype ? resultComparator.firstHomMatch() : resultComparator.firstMatch();
                        if (dualIdx.isSplitVariantValid()) {
                            // validated
                            validatedTrue.set(dualIdx.splitVariantIndex);
                            fullValidatedCount[dualIdx.wholeVariantIndex] += maxTrueLength;// this 'should' be overlap len
                            validatedLength += currentVariant.maxLen();
                        } else if (computeAsSplit) {
                            if (!skipFP) {
                                outputBlob.getNumberOfTrueCorrect().incFP(currentVariant.getType(), variant.maxLen());
                                validator.inc(StatsNamespace.FP, currentVariant.getType(), variant.maxLen());
                                variant.output(fpWriter);
                            } else {
                                variant.output(unknownFpWriter);
                            }
                        }

                    } else {
                        // het
                        //boolean matched = false;
                        int maxTrueLen = 0;
                        /*
                        for heterozygous variants, all genotypes will be checked
                        inside compareVariant, all genotypes of overlapping true variants will be checked, too
                        so overall all possible combinations of genotype matching will be checked
                        */
                        for (int i = 0; i < 2; i++) {
                            byte allele = geno.geno[i];
                            if (allele > 0) {
                                maxTrueLen = Math.max(resultComparator.compareVariant(currentVariant, allele, validatedTrue), maxTrueLen);
                            }
                        }

                        final DualIdx dualIdx = matchGenotype ? resultComparator.firstHetMatch() : resultComparator.firstMatch();

                        if (dualIdx.isSplitVariantValid()) {
                            validatedTrue.set(dualIdx.splitVariantIndex);
                            fullValidatedCount[dualIdx.wholeVariantIndex] += currentVariant.maxLen(); // this 'should' be overlap len
                            validatedLength += currentVariant.maxLen();
                        } else if (computeAsSplit) {
                            if (!skipFP) {
                                outputBlob.getNumberOfTrueCorrect().incFP(currentVariant.getType(), currentVariant.maxLen());
                                validator.inc(StatsNamespace.FP, currentVariant.getType(), currentVariant.maxLen());
                                if (currentVariant.getType() == VariantOverallType.SNP && currentVariant.maxLen() > 1) {
                                    log.warn("SNP with bad length: " + currentVariant);
                                }
                                variant.output(fpWriter);
                            } else {
                                variant.output(unknownFpWriter);
                            }
                        }
                    }
                }

                if (!computeAsSplit && validatedLength < (totalLength * overlapRatio)) {
                    if (!skipFP) {
                        // this is a false positive!
                        outputBlob.getNumberOfTrueCorrect().incFP(currentVariantType, variant.maxLen());
                        validator.inc(StatsNamespace.FP, currentVariantType, variant.maxLen());
                        if (currentVariantType == VariantOverallType.SNP && variant.maxLen() > 1) {
                            log.warn("SNP with bad length: " + variant);
                        }
                        variant.output(fpWriter);
                    } else {
                        variant.output(unknownFpWriter);
                    }
                }

                numberOfNewVariants++;
            }
        }

        log.info("Num new variants read: " + numberOfNewVariants);

        // read through again and compute for the true variants
        int numRead2 = 0;
        for (Variant var : trueVariantsForOutput) {

            boolean isKnown = intersector == null || excludeTprFromBedFiltering;

            if (var.getCompositions() == null) {
                isKnown = isKnown || intersector.containsEndpoints(var.getChr(), var.getGenotypeUnionAlternativeInterval(), bedEither);
            } else {
                for (Variant c : var.getCompositions()) {
                    isKnown = isKnown || intersector.containsEndpoints(c.getChr(), c.getGenotypeUnionAlternativeInterval(), bedEither);
                }
            }
            if (isKnown) {
                int totalLength = validatedTotalLength.get(numRead2);
                int validatedLength = fullValidatedCount[numRead2];

              //if a variant is canonicalized into a few smaller variants, validation
                //will be carried out on a per-variant basis. An original variant will
                //be considered a match only if the sum of lengths of all its VALIDATED
                //canonicalized variants is larger than overlapRatio * totalLength
                if (validatedLength >= (overlapRatio * totalLength)) {
                    // validated
                    outputBlob.getNumberOfTrueCorrect().incTP(var.getType(), var.maxLen());
                    validator.inc(StatsNamespace.TP, var.getType(), var.maxLen());
                    var.output(tpWriter);
                } else {
                    var.output(fnWriter);
                }

                outputBlob.getNumberOfTrueCorrect().incT(var.getType(), var.maxLen());
                validator.inc(StatsNamespace.T, var.getType(), var.maxLen());
            } else {
                var.output(unknownTpWriter);
            }
            numRead2++;
        }

        if (numReadOriginalVariant != numRead2) {
            log.error("Number of variants read are inconsistent: " + numReadOriginalVariant + "," + numRead2);
        }

        // Compute and update the true negatives here so that we have specificity values
        if (referenceGenome != null) {
            final VariantOverallType variantOverallTypes[] = {VariantOverallType.SNP, VariantOverallType.Insertion, VariantOverallType.Deletion};
            for (final VariantOverallType variantOverallType : variantOverallTypes) {
                if (outputBlob.getNumberOfTrueCorrect().getData().containsKey(variantOverallType)) {
                    outputBlob.getNumberOfTrueCorrect().getData().get(variantOverallType).computeTN((int) referenceGenome.getNumNonNBases());
                }
            }
        }


        // output the stats
        System.err.println(outputBlob.getNumberOfTrueCorrect());

        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, false);

        String jsonStr = "";
        try {
            jsonStr = mapper.writeValueAsString(outputBlob);
            jsonWriter.print(jsonStr);
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (htmlFile != null) {
            try {
                FileUtils.writeStringToFile(new File(outPrefix + "_varcomp.html"),
                        JSONInserter.insertJSON(FileUtils.readFileToString(htmlFile), jsonStr));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }

        // Check the validity
        try {
            validator.testValidity();
        } catch (UnsatisfiedConstraintException e) {
            log.error("A number of constraints were not satisfied:");
            for (UnsatisfiedConstraintException.valuePair constraint : e.getConstraints()) {
                log.error(String.format("%.4f : %s", constraint.getActualValue(), constraint.getConstraint()));
            }
            System.exit(1);
        }

        log.info("Done!"); // used to record the time
    }

    /**
     * globalMatching matches truth and test variants
     * on a global basis, i.e. maximize overall matched
     * variant pairs.
     *
     * some implementation details:
     * *****************************************************
     * *****CAUTION: subject to change without notice*******
     * *****************************************************
     * true variants and test variants are joined by edges if
     * they match with each other based on user-specified
     * criteria. The edges will be assigned weights, i.e.
     * rankings among all the pairings based on degree of
     * matching. The variants and pairings are used to construct
     * an undirected weighted bipartite graph. Solution to
     * maximum-weighted bipartite matching will be used to
     * determine final pairing between true and test variants.
     *
     * note here, no more than one true/test variants will be
     * paired with each test/true variant. In other words,
     * degree of vertices is no more than 1.
     */
    private void globalMatching() {

        // these are the statistics we "ideally" want to collect
        // number of variants correct (either genotype) (for each type)
        // number homozygous correct (for each type)
        // number heterozygous correct (for each type)
        // number homozygous genotype correct (for each type)
        // number heterozyous genotype correct (for each type)


        BedFile intersector = null;
        boolean bedExists = false;
        // check if the file exists
        try {
            File f = new File(bedFilename);
            bedExists = f.exists();
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (bedExists) {
            log.info("Using " + bedFilename + " to intersect");
            intersector = new BedFile(bedFilename);
        } else {
            if (excludeTprFromBedFiltering || excludeFdfFromBedFiltering) {
                log.warn("No BED file specified but used exclude parameters");
            }
        }

        Set<String> chrAcceptor = null;
        //TODO: make chrAcceptor a class
        if (chromosomeToBeIncluded != null) {
            chrAcceptor = new HashSet<>(Arrays.asList(chromosomeToBeIncluded.split(",")));
            log.info("Only accepting chromosomes: " + Arrays.toString(chrAcceptor.toArray()));
        }

        ConstraintValidator validator = new ConstraintValidator(constraintArgs);

        // Load refernece genome
        SimpleReference referenceGenome = reference == null ? null : new SimpleReference(reference);

        // load true VCF into interval tree
        log.info("Load Truth VCF");

        outputClass outputBlob = new outputClass();

        outputBlob.setParams(new CompareParams());
        outputBlob.getParams().setBedFilename(bedFilename);
        // TODO: make it output the full list if variants in JSON
        outputBlob.getParams().setNewVcfFilename(newVcfFilename.get(0));
        outputBlob.getParams().setOverlapPercent(overlapRatio);
        outputBlob.getParams().setTrueVcfFilename(trueVcfFilename);
        outputBlob.getParams().setWiggle(wiggle);

        VCFparser trueVcfParser = new VCFparser(trueVcfFilename, null, false);

        // allow duplicates, this is needed because insertions don't actually take up a location
        chrSearchTree<ValueInterval1D<Variant>> trueVariantIntervalTree = new chrSearchTree<>(true);
        int numReadOriginalVariant = 0;
        int numAddedSplitVariant = 0;


        //track TRAID-linked variants
        Map<String, List<Variant>> traid2composingVariants = new HashMap<>();

        // this is for the original variants
        // it stores the total length of the original variant in bases
        // Still check for validation of canonical full variants
        ArrayList<Integer> validatedTotalLength = new ArrayList<>();
        ArrayList<Variant> trueVariantsForOutput = new ArrayList<>();

        Set<Variant> canonicalizedTrueVariants = new HashSet<>();
        Set<Variant> canonicalizedTestVariants = new HashSet<>();
        List<VariantPair> allCanonicalizedVariantPairs = new ArrayList<>();
        UndirectedWeightedGraphBuilderBase weightedGraphBuilder = SimpleWeightedGraph.builder(VariantPair.class);
        Graph<Variant, VariantPair> bipartiteTrueVsTestVariantGraph = null;

        // For each true variant, if the number of bases validated is over a certain threshold
        // call it correct
        outputBlob.setNumberOfTrueCorrect(new EnumStatsRatioCounter<VariantOverallType>());

        // For called variants, break down into canonical ones and count based on that
        // if any called variant overlaps a complex variant or MNP, count it as "complex"
        // otherwise, simple count them in their canonical forms

        // store true variants as canonical ones, but remember original form
        while (trueVcfParser.hasMoreInput()) {
            Variant trueVariant = trueVcfParser.parseLine();
            if (trueVariant == null ||
                    (!trueVariant.getGenotypes().isNonRef()) ||
                    (chrAcceptor != null && !chrAcceptor.contains(trueVariant.getChr().getName()))) {
                log.info("skip line");
                continue;
            }

            VariantOverallType trueVariantOriginalType = trueVariant.getType();

            if (trueVariant.getTraid() != null) {
                String currentTraid = trueVariant.getTraid();
                if (traid2composingVariants.containsKey(currentTraid)) {
                    traid2composingVariants.get(currentTraid).add(trueVariant);
                    trueVariant = new Variant.Builder().compositions(traid2composingVariants.get(currentTraid)).build();
                    traid2composingVariants.remove(currentTraid);
                } else {
                    traid2composingVariants.put(currentTraid, new ArrayList<Variant>());
                    traid2composingVariants.get(currentTraid).add(trueVariant);
                    continue;
                }
            }
            // determine max variant region
            // when comparing genotypes, we need to individually compare
            // to make sure they really overlap

            //TODO: remove constructor here (because another copy will be created inside canonicalizeVariant
            List<Variant> canonicalVariantList = canonicalizeVariant(new Variant(trueVariant));

            int totalLength = canonicalVariantList.stream().mapToInt(v -> v.maxLen()).sum();
            int maxLength = canonicalVariantList.stream().mapToInt(v -> v.maxLen()).max().getAsInt();

            // add to interval tree
            for (Variant currentVariant : canonicalVariantList) {

                ChrString chr = currentVariant.getChr();
                SimpleInterval1D currentVariantInterval = null;
                try {
                    currentVariantInterval = currentVariant.getGenotypeUnionVariantInterval();
                } catch (Exception e) {
                    e.printStackTrace();
                    log.error("Original variant: " + trueVariant);
                    log.error("Bad variant: " + currentVariant);
                    System.exit(1);
                }
                currentVariant.splitVariantIndex = numAddedSplitVariant;
                currentVariant.wholeVariantIndex = numReadOriginalVariant;
                currentVariant.originalType = trueVariantOriginalType;

                trueVariantIntervalTree.put(chr, new ValueInterval1D<>(currentVariantInterval, currentVariant));
                canonicalizedTrueVariants.add(currentVariant);
                numAddedSplitVariant++;
            }

            if (totalLength >= Constant.SVLEN && maxLength >= overlapRatio * totalLength && canonicalVariantList.size() > 1) {
                // in this case we break down the variant into canoical forms since
                // the original variant was probably a large deletion with a small insertion
                for (Variant currentVariant : canonicalVariantList) {
                    int currentLength = currentVariant.maxLen();
                    validatedTotalLength.add(currentLength);
                    trueVariantsForOutput.add(currentVariant);
                    numReadOriginalVariant++;
                }
            } else {
                validatedTotalLength.add(totalLength);
                trueVariantsForOutput.add(trueVariant);
                numReadOriginalVariant++;
            }
        }

        log.info("Num read:  " + numReadOriginalVariant);
        log.info("Num added: " + numAddedSplitVariant);
        log.info("Num nodes: " + trueVariantIntervalTree.size());
        log.info("Max depth: " + trueVariantIntervalTree.maxDepth());

        // this is for the split variants
        // set to true if the canonical original variant was validated true
        BitSet validatedTrue = new BitSet(numAddedSplitVariant);

        // this is for the original variants
        // count of the number of bases validated for the original variant
        int[] fullValidatedCount = new int[numReadOriginalVariant];

        // generate the output files
        try (
                PrintWriter tpWriter = TP_WRITER.getWriter(outPrefix);
                PrintWriter unknownTpWriter = UNKNOWN_TP_WRITER.getWriter(outPrefix);
                PrintWriter fpWriter = FP_WRITER.getWriter(outPrefix);
                PrintWriter unknownFpWriter = UNKNOWN_FP_WRITER.getWriter(outPrefix);
                PrintWriter fnWriter = FN_WRITER.getWriter(outPrefix);
                PrintWriter jsonWriter = JSON_WRITER.getWriter(outPrefix);) {


            // for this case we add to false positives if the variant is not validated.
            // However, do don't add to true positives, those that computed later

            log.info("Load New VCF");
            int numberOfNewVariants = 0;
            // iterate over new VCF and collect stats

            traid2composingVariants.clear();
            MultiResultComparator multiResultComparator = new MultiResultComparator(trueVariantIntervalTree, overlapRatio,
                    wiggle, ignoreInsertionLength, matchGenotype);

            for (String currentVcfFile : newVcfFilename) {
                VCFparser newParser = new VCFparser(currentVcfFile, sampleName, excludeFiltered);

                while (newParser.hasMoreInput()) {
                    Variant variant = newParser.parseLine();

                    //TODO: wrap variant comparison into a method for easier reading
                    if (variant == null ||
                            (chrAcceptor != null && !chrAcceptor.contains(variant.getChr().getName()))) {
                        log.info("skip line");
                        continue;
                    }

                    boolean skipFP = false;

                    if (variant.getTraid() != null) {
                        String currentTraid = variant.getTraid();
                        if (traid2composingVariants.containsKey(currentTraid)) {
                            traid2composingVariants.get(currentTraid).add(variant);
                            variant = new Variant.Builder().compositions(traid2composingVariants.get(currentTraid)).build();
                            traid2composingVariants.remove(currentTraid);
                            if (intersector != null) {
                                for (Variant c : variant.getCompositions()) {
                                    if (!excludeFdfFromBedFiltering && !intersector.containsEndpoints(c.getChr(), c.getGenotypeUnionAlternativeInterval(), bedEither)) {
                                        skipFP = true;
                                    }
                                }
                            }
                        } else {
                            traid2composingVariants.put(currentTraid, new ArrayList<Variant>());
                            traid2composingVariants.get(currentTraid).add(variant);
                            continue;
                        }
                    } else {
                        if (intersector != null) {
                            if (!excludeFdfFromBedFiltering && !intersector.containsEndpoints(variant.getChr(), variant.getGenotypeUnionAlternativeInterval(), bedEither)) {
                                skipFP = true;
                            }
                        }
                    }

                    // the overall type of the called variant
                    VariantOverallType currentVariantType = variant.getType();

                    // if called as complex variant convert to indel+snps
                    List<Variant> canonicalVariantList = canonicalizeVariant(variant);

                    int totalLength = canonicalVariantList.stream().mapToInt(v -> v.maxLen()).sum();
                    double validatedLength = 0;
                    int maxLength = canonicalVariantList.stream().mapToInt(v -> v.maxLen()).max().getAsInt();

                    // split up variants that are basically one big variant and one small one
                    //maxLength / totalLength >= overlapRatio, true if the longest canonicalized variant
                    //is longer than certain proportion of sum of lengths of all canonicalized variants.
                    boolean computeAsSplit = totalLength >= Constant.SVLEN && maxLength >= overlapRatio * totalLength  &&
                            canonicalVariantList.size() > 1;

                  /*
                  here we need to figure out all possible pairings between current test variant
                  and true variants, the pairings will be sorted later based on degree of matching
                   */
                    for (Variant currentVariant : canonicalVariantList) {
                        canonicalizedTestVariants.add(currentVariant);
                        allCanonicalizedVariantPairs.addAll(multiResultComparator.findAllPairs(currentVariant));
                    }
                            for (int i = 0; i < 2; i++) {
                                byte allele = geno.geno[i];
                                if (allele > 0) {
                                    maxTrueLen = Math.max(resultComparator.compareVariant(currentVariant, allele, validatedTrue), maxTrueLen);
                                }
                            }

                            final DualIdx dualIdx = matchGenotype ? resultComparator.firstHetMatch() : resultComparator.firstMatch();

                            if (dualIdx.isSplitVariantValid()) {
                                validatedTrue.set(dualIdx.splitVariantIndex);
                                fullValidatedCount[dualIdx.wholeVariantIndex] += currentVariant.maxLen(); // this 'should' be overlap len
                                validatedLength += currentVariant.maxLen();
                            } else if (computeAsSplit) {
                                if (!skipFP) {
                                    outputBlob.getNumberOfTrueCorrect().incFP(currentVariant.getType(), currentVariant.maxLen());
                                    validator.inc(StatsNamespace.FP, currentVariant.getType(), currentVariant.maxLen());
                                    if (currentVariant.getType() == VariantOverallType.SNP && currentVariant.maxLen() > 1) {
                                        log.warn("SNP with bad length: " + currentVariant);
                                    }
                                    variant.output(fpWriter);
                                } else {
                                    variant.output(unknownFpWriter);
                                }
                            }
                        }
                    }

                    if (!computeAsSplit && validatedLength < (totalLength * overlapRatio)) {
                        if (!skipFP) {
                            // this is a false positive!
                            outputBlob.getNumberOfTrueCorrect().incFP(currentVariantType, variant.maxLen());
                            validator.inc(StatsNamespace.FP, currentVariantType, variant.maxLen());
                            if (currentVariantType == VariantOverallType.SNP && variant.maxLen() > 1) {
                                log.warn("SNP with bad length: " + variant);
                            }
                            variant.output(fpWriter);
                        } else {
                            variant.output(unknownFpWriter);
                        }
                    }

                    numberOfNewVariants++;
                }
            }
            /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        //perform global matching
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
        /**********/
//            for (String currentVcfFile : newVcfFilename) {
//                VCFparser newParser = new VCFparser(currentVcfFile, sampleName, excludeFiltered);
//
//                while (newParser.hasMoreInput()) {
//                    Variant variant = newParser.parseLine();
//
//                    //TODO: wrap variant comparison into a method for easier reading
//                    if (variant == null ||
//                            (chrAcceptor != null && !chrAcceptor.contains(variant.getChr().getName()))) {
//                        log.info("skip line");
//                        continue;
//                    }
//
//                    boolean skipFP = false;
//
//                    if (variant.getTraid() != null) {
//                        String currentTraid = variant.getTraid();
//                        if (traid2composingVariants.containsKey(currentTraid)) {
//                            traid2composingVariants.get(currentTraid).add(variant);
//                            variant = new Variant.Builder().compositions(traid2composingVariants.get(currentTraid)).build();
//                            traid2composingVariants.remove(currentTraid);
//                            if (intersector != null) {
//                                for (Variant c : variant.getCompositions()) {
//                                    if (!excludeFdfFromBedFiltering && !intersector.containsEndpoints(c.getChr(), c.getGenotypeUnionAlternativeInterval(), bedEither)) {
//                                        skipFP = true;
//                                    }
//                                }
//                            }
//                        } else {
//                            traid2composingVariants.put(currentTraid, new ArrayList<Variant>());
//                            traid2composingVariants.get(currentTraid).add(variant);
//                            continue;
//                        }
//                    } else {
//                        if (intersector != null) {
//                            if (!excludeFdfFromBedFiltering && !intersector.containsEndpoints(variant.getChr(), variant.getGenotypeUnionAlternativeInterval(), bedEither)) {
//                                skipFP = true;
//                            }
//                        }
//                    }
//
//                    // the overall type of the called variant
//                    VariantOverallType currentVariantType = variant.getType();
//
//                    // if called as complex variant convert to indel+snps
//                    List<Variant> canonicalVariantList = canonicalizeVariant(variant);
//
//                    int totalLength = canonicalVariantList.stream().mapToInt(v -> v.maxLen()).sum();
//                    double validatedLength = 0;
//                    int maxLength = canonicalVariantList.stream().mapToInt(v -> v.maxLen()).max().getAsInt();
//
//                    // split up variants that are basically one big variant and one small one
//                    //maxLength / totalLength >= overlapRatio, true if the longest canonicalized variant
//                    //is longer than certain proportion of sum of lengths of all canonicalized variants.
//                    boolean computeAsSplit = totalLength >= Constant.SVLEN && maxLength >= overlapRatio * totalLength  &&
//                            canonicalVariantList.size() > 1;
//
//                    for (Variant currentVariant : canonicalVariantList) {
//                        canonicalizedTestVariants.add(currentVariant);
//                    // get genotype
//                    Genotypes geno = currentVariant.getGenotypes();
//                    //note here ResultComparator is created for each canonical variant
//                    ResultComparator resultComparator = new ResultComparator(trueVariantIntervalTree, overlapRatio, wiggle, ignoreInsertionLength);
//
//                    if (currentVariant.isHom()) {
//                        int maxTrueLength = resultComparator.compareVariant(currentVariant, geno.geno[0], validatedTrue);
//                        final DualIdx dualIdx = matchGenotype ? resultComparator.isHomMatch() : resultComparator.firstMatch();
//                        if (dualIdx.isSplitVariantValid()) {
//                            // validated
//                            validatedTrue.set(dualIdx.splitVariantIndex);
//                            fullValidatedCount[dualIdx.wholeVariantIndex] += maxTrueLength;// this 'should' be overlap len
//                            validatedLength += currentVariant.maxLen();
//                        } else if (computeAsSplit) {
//                            if (!skipFP) {
//                                outputBlob.getNumberOfTrueCorrect().incFP(currentVariant.getType(), variant.maxLen());
//                                validator.inc(StatsNamespace.FP, currentVariant.getType(), variant.maxLen());
//                                variant.output(fpWriter);
//                            } else {
//                                variant.output(unknownFpWriter);
//                            }
//                        }
//
//                    } else {
//                        // het
//                        //boolean matched = false;
//                        int maxTrueLen = 0;
//                        /*
//                        for heterozygous variants, all genotypes will be checked
//                        inside compareVariant, all genotypes of overlapping true variants will be checked, too
//                        so overall all possible combinations of genotype matching will be checked
//                        */
//                        for (int i = 0; i < 2; i++) {
//                            byte allele = geno.geno[i];
//                            if (allele > 0) {
//                                maxTrueLen = Math.max(resultComparator.compareVariant(currentVariant, allele, validatedTrue), maxTrueLen);
//                            }
//                        }
//
//                        final DualIdx dualIdx = matchGenotype ? resultComparator.firstHetMatch() : resultComparator.firstMatch();
//
//                        if (dualIdx.isSplitVariantValid()) {
//                            validatedTrue.set(dualIdx.splitVariantIndex);
//                            fullValidatedCount[dualIdx.wholeVariantIndex] += currentVariant.maxLen(); // this 'should' be overlap len
//                            validatedLength += currentVariant.maxLen();
//                        } else if (computeAsSplit) {
//                            if (!skipFP) {
//                                outputBlob.getNumberOfTrueCorrect().incFP(currentVariant.getType(), currentVariant.maxLen());
//                                validator.inc(StatsNamespace.FP, currentVariant.getType(), currentVariant.maxLen());
//                                if (currentVariant.getType() == VariantOverallType.SNP && currentVariant.maxLen() > 1) {
//                                    log.warn("SNP with bad length: " + currentVariant);
//                                }
//                                variant.output(fpWriter);
//                            } else {
//                                variant.output(unknownFpWriter);
//                            }
//                        }
//                    }
//                }
//
//                if (!computeAsSplit && validatedLength < (totalLength * overlapRatio)) {
//                    if (!skipFP) {
//                        // this is a false positive!
//                        outputBlob.getNumberOfTrueCorrect().incFP(currentVariantType, variant.maxLen());
//                        validator.inc(StatsNamespace.FP, currentVariantType, variant.maxLen());
//                        if (currentVariantType == VariantOverallType.SNP && variant.maxLen() > 1) {
//                            log.warn("SNP with bad length: " + variant);
//                        }
//                        variant.output(fpWriter);
//                    } else {
//                        variant.output(unknownFpWriter);
//                    }
//                }
//
//                numberOfNewVariants++;
//            }
//        }

            log.info("Num new variants read: " + numberOfNewVariants);

            // read through again and compute for the true variants
            int numRead2 = 0;
            for (Variant var : trueVariantsForOutput) {

                boolean isKnown = intersector == null || excludeTprFromBedFiltering;

                if (var.getCompositions() == null) {
                    isKnown = isKnown || intersector.containsEndpoints(var.getChr(), var.getGenotypeUnionAlternativeInterval(), bedEither);
                } else {
                    for (Variant c : var.getCompositions()) {
                        isKnown = isKnown || intersector.containsEndpoints(c.getChr(), c.getGenotypeUnionAlternativeInterval(), bedEither);
                    }
                }
                if (isKnown) {
                    int totalLength = validatedTotalLength.get(numRead2);
                    int validatedLength = fullValidatedCount[numRead2];

                    //if a variant is canonicalized into a few smaller variants, validation
                    //will be carried out on a per-variant basis. An original variant will
                    //be considered a match only if the sum of lengths of all its VALIDATED
                    //canonicalized variants is larger than overlapRatio * totalLength
                    if (validatedLength >= (overlapRatio * totalLength)) {
                        // validated
                        outputBlob.getNumberOfTrueCorrect().incTP(var.getType(), var.maxLen());
                        validator.inc(StatsNamespace.TP, var.getType(), var.maxLen());
                        var.output(tpWriter);
                    } else {
                        var.output(fnWriter);
                    }

                    outputBlob.getNumberOfTrueCorrect().incT(var.getType(), var.maxLen());
                    validator.inc(StatsNamespace.T, var.getType(), var.maxLen());
                } else {
                    var.output(unknownTpWriter);
                }
                numRead2++;
            }

            if (numReadOriginalVariant != numRead2) {
                log.error("Number of variants read are inconsistent: " + numReadOriginalVariant + "," + numRead2);
            }

            // Compute and update the true negatives here so that we have specificity values
            if (referenceGenome != null) {
                final VariantOverallType variantOverallTypes[] = {VariantOverallType.SNP, VariantOverallType.Insertion, VariantOverallType.Deletion};
                for (final VariantOverallType variantOverallType : variantOverallTypes) {
                    if (outputBlob.getNumberOfTrueCorrect().getData().containsKey(variantOverallType)) {
                        outputBlob.getNumberOfTrueCorrect().getData().get(variantOverallType).computeTN((int) referenceGenome.getNumNonNBases());
                    }
                }
            }


            // output the stats
            System.err.println(outputBlob.getNumberOfTrueCorrect());

            ObjectMapper mapper = new ObjectMapper();
            mapper.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, false);

            String jsonStr = "";
            try {
                jsonStr = mapper.writeValueAsString(outputBlob);
                jsonWriter.print(jsonStr);
            } catch (Exception e) {
                e.printStackTrace();
            }

            if (htmlFile != null) {
                try {
                    FileUtils.writeStringToFile(new File(outPrefix + "_varcomp.html"),
                            JSONInserter.insertJSON(FileUtils.readFileToString(htmlFile), jsonStr));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }

        // Check the validity
        try {
            validator.testValidity();
        } catch (UnsatisfiedConstraintException e) {
            log.error("A number of constraints were not satisfied:");
            for (UnsatisfiedConstraintException.valuePair constraint : e.getConstraints()) {
                log.error(String.format("%.4f : %s", constraint.getActualValue(), constraint.getConstraint()));
            }
            System.exit(1);
        }

        log.info("Done!"); // used to record the time
    }
    /**
     * This is just for outputting to JSON
     */
    class outputClass {
        CompareParams params;
        @JsonProperty(value = "num_true_correct")
        EnumStatsRatioCounter<VariantOverallType> numberOfTrueCorrect;

        outputClass(CompareParams params, EnumStatsRatioCounter<VariantOverallType> numberOfTrueCorrect) {
            this.params = params;
            this.numberOfTrueCorrect = numberOfTrueCorrect;
        }

        outputClass() {
        }

        public CompareParams getParams() {
            return params;
        }

        public void setParams(CompareParams params) {
            this.params = params;
        }

        public EnumStatsRatioCounter<VariantOverallType> getNumberOfTrueCorrect() {
            return numberOfTrueCorrect;
        }

        public void setNumberOfTrueCorrect(EnumStatsRatioCounter<VariantOverallType> numberOfTrueCorrect) {
            this.numberOfTrueCorrect = numberOfTrueCorrect;
        }
    }

    class CompareParams {
        @JsonProperty(value = "true_vcf_filename")
        String trueVcfFilename;
        @JsonProperty(value = "new_vcf_filename")
        String newVcfFilename;
        @JsonProperty(value = "overlap_percent")
        Double overlapRatio;
        int wiggle;
        @JsonProperty(value = "bed_filename")
        String bedFilename;

        public CompareParams() {
        }

        public CompareParams(String trueVcfFilename, String newVcfFilename, Double overlapRatio, int wiggle, String bedFilename) {
            this.trueVcfFilename = trueVcfFilename;
            this.newVcfFilename = newVcfFilename;
            this.overlapRatio = overlapRatio;
            this.wiggle = wiggle;
            this.bedFilename = bedFilename;
        }


        public String getTrueVcfFilename() {
            return trueVcfFilename;
        }

        public void setTrueVcfFilename(String trueVcfFilename) {
            this.trueVcfFilename = trueVcfFilename;
        }

        public String getNewVcfFilename() {
            return newVcfFilename;
        }

        public void setNewVcfFilename(String newVcfFilename) {
            this.newVcfFilename = newVcfFilename;
        }

        public Double getOverlapPercent() {
            return overlapRatio;
        }

        public void setOverlapPercent(Double overlapRatio) {
            this.overlapRatio = overlapRatio;
        }

        public int getWiggle() {
            return wiggle;
        }

        public void setWiggle(int wiggle) {
            this.wiggle = wiggle;
        }

        public String getBedFilename() {
            return bedFilename;
        }

        public void setBedFilename(String bedFilename) {
            this.bedFilename = bedFilename;
        }
    }

    class DualIdx {
        public int splitVariantIndex;
        public int wholeVariantIndex;

        /**
         * constructor for this class given known splitVariantIndex and wholeVariantIndex
         * @param splitVariantIndex
         * @param wholeVariantIndex
         */
        DualIdx(int splitVariantIndex, int wholeVariantIndex) {
            this.splitVariantIndex = splitVariantIndex;
            this.wholeVariantIndex = wholeVariantIndex;
        }

        /**
         * initialize to -1 which means no valid variant available
         */
        DualIdx() {
            splitVariantIndex = -1;
            wholeVariantIndex = -1;
        }

        public boolean isSplitVariantValid() {
            return splitVariantIndex >= 0;
        }
        public boolean isWholeVariantValid() {
            return wholeVariantIndex >= 0;
        }
        public boolean equals(Object obj) {
            if (obj == this)
                return true;
            if (!(obj instanceof DualIdx))
                return false;

            // use EqualsBuilder?
            DualIdx temp = (DualIdx) obj;
            if (splitVariantIndex != temp.splitVariantIndex) {
                return false;
            }

            return wholeVariantIndex == temp.wholeVariantIndex;

        }

        @Override
        public String toString() {
            return "DualIdx{" +
                   "splitVariantIndex=" + splitVariantIndex +
                    ", wholeVariantIndex=" + wholeVariantIndex +
                    '}';
        }
    }

    /**
     * inner class for finding a matched true variant
     * only handles 1 matched variant
     *
     * main purpose is for backward compatibility
     * should favor {@link MultiResultComparator}
     */
    class ResultComparator {

        chrSearchTree<ValueInterval1D<Variant>> trueVariantIntervalTree; // true variants
        double overlapRatio;
        boolean overlapComplex;
        int wiggle;
        boolean ignoreInsertionLength;

        // Results to store
        // this stores the indexes of the true variants matched
        List<DualIdx> homozygousMatches = new ArrayList<>();
        List<List<DualIdx>> heterozygousMatches = Arrays.asList(new ArrayList<DualIdx>(), new ArrayList<DualIdx>()); // matches either parent

        public ResultComparator(chrSearchTree<ValueInterval1D<Variant>> trueVariantIntervalTree, double overlapRatio, int wiggle, boolean ignoreInsLen) {
            this.trueVariantIntervalTree = trueVariantIntervalTree;
            this.overlapRatio = overlapRatio;
            this.wiggle = wiggle;

            overlapComplex = false;
            ignoreInsertionLength = ignoreInsLen;
        }

        /**
         * return first homozygous match (empty if no match)
         * @return
         */
        public DualIdx firstHomMatch() {
            return homozygousMatches.isEmpty() ? new DualIdx() : homozygousMatches.get(0);
        }

        /**
         * return first heterozygous match (empty if no match)
         * @return
         */
        public DualIdx firstHetMatch() {
            List<DualIdx> temp = new ArrayList<>(heterozygousMatches.get(0));
            temp.retainAll(heterozygousMatches.get(1)); //essentially get intersection
            //if there is a match in intersection, return the first one from the intersection
            if (!temp.isEmpty()) {
                return temp.get(0);
              /*
              if no match in intersection, return the first one from the larger list (the genotype
              containing more heterozygous matches).
              since ResultComparator is created for each variant, heterzygousMatches will only
              store matches for one variant against some true variants. Therefore, I think
              one of the lists in heterozygousMatches will always be zero if there is no intersection
              between them. And in such cases, we just return whatever we have in matches.

              an example, compare these two lines:
              1	993	rs35493185	C	CA	.	.	SVLEN=1	GT	1|0
              1	993	rs35493185	C	CA	.	.	SVLEN=1	GT	1|0

               */
            } else if (heterozygousMatches.stream().anyMatch(l -> !l.isEmpty())) {
                if (heterozygousMatches.get(0).size() > heterozygousMatches.get(1).size()) {
                    return heterozygousMatches.get(0).get(0);
                } else {
                    return heterozygousMatches.get(1).get(0);
                }
            }
            return new DualIdx();
        }

        /**
         * determine if there is a match regardless of genotype
         * @return DualIdx of matched variant
         */
        public DualIdx firstMatch() {
            DualIdx idx = firstHomMatch();
            if (idx.isSplitVariantValid()) {
                return idx;
            }
            idx = firstHetMatch();
            if (idx.isSplitVariantValid()) {
                return idx;
            }
            return idx;
        }

        /**
         * Only compares one allele at a time
         * - don't match variants in the bitset
         * - if match set the bitset
         *
         * @param variant       variant we want to compare
         * @param genotype      allele of the variant to compare
         * @return The maximum length of all true variants
         */
        public int compareVariant(Variant variant, int genotype) {
            return compareVariant(variant, genotype, new BitSet());
        }
        /**
         * Only compares one allele at a time
         * - don't match variants in the bitset
         * - if match set the bitset
         *
         * @param variant       variant we want to compare
         * @param genotype      allele of the variant to compare
         * @param validated BitSet that records the true variants that have already been validated
         *                  can be empty BitSet if we don't skip validated ones
         * @return The maximum length of all true variants
         */
        public int compareVariant(Variant variant, int genotype, BitSet validated) {
            //TODO: consider type to change overlap percent
            VariantType type = variant.getType(genotype);
            ChrString chr = variant.getChr();
            SimpleInterval1D intervalForCompare = variant.getVariantInterval(genotype, ignoreInsertionLength);

            int maxTrueVarianLength = 0;

            // sometimes MNPs are called as SNPs?
            if (type == VariantType.SNP) {
                // handle SNPs differently
                // require SNP content to match
                Iterable<ValueInterval1D<Variant>> overlaps = trueVariantIntervalTree.getOverlaps(chr, intervalForCompare);

                if (overlaps == null) {
                    // nothing found
                    return maxTrueVarianLength;
                }

                byte alternativeAlleleFirstBase = variant.getAlt(genotype).getSequence()[0];

                int numberOfSnpMatches = 0;
                for (ValueInterval1D<Variant> trueVariantInterval : overlaps) {
                    Variant trueVariant = trueVariantInterval.getContent();
                    boolean hasSnp = false;
                    int splitVariantIndex = trueVariant.splitVariantIndex;
                    int wholeVariantIndex = trueVariant.wholeVariantIndex;
                    overlapComplex = trueVariant.originalType == VariantOverallType.Complex;

                    if (validated.get(splitVariantIndex)) {
                        // skip ones already validated
                        continue;
                    }

                    // check genotype
                    for (int parent = 0; parent < 2; parent++) {
                        int allele = trueVariant.getAllele(parent);
                        //true variant is heterozygous, so only one allele has non-reference sequence
                        if (trueVariant.isHom() || allele > 0) {
                            if (trueVariant.getType(allele) == VariantType.SNP
                                    && variant.getPos() == trueVariant.getPos()) {
                                if (alternativeAlleleFirstBase == trueVariant.getAlt(allele).getSequence()[0]) {
                                    if (trueVariant.isHom())
                                        homozygousMatches.add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                                    else
                                        heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                                }
                                hasSnp = true;
                            }
                        }
                        if (trueVariant.isHom())
                            break;
                    }

                    if (hasSnp) {
                        numberOfSnpMatches++;
                        maxTrueVarianLength = 1;
                    }
                }

                if (numberOfSnpMatches > 1) {
                    log.info("Something strange, multiple SNP matches in true set: " + numberOfSnpMatches);
                }
            } else {
                // Non-SNPs
                SimpleInterval1D intervalForCompareWithWiggle = new SimpleInterval1D(intervalForCompare.left - wiggle, intervalForCompare.right + wiggle);
                Iterable<ValueInterval1D<Variant>> overlaps = trueVariantIntervalTree.getOverlaps(chr, intervalForCompareWithWiggle);

                if (overlaps == null) {
                    // nothing found
                    return maxTrueVarianLength;
                }

                for (ValueInterval1D<Variant> trueVariantInterval : overlaps) {
                    Variant trueVariant = trueVariantInterval.getContent();
                    int splitVariantIndex = trueVariant.splitVariantIndex;
                    int wholeVariantIndex = trueVariant.wholeVariantIndex;
                    overlapComplex = trueVariant.originalType == VariantOverallType.Complex;

                    if (validated.get(splitVariantIndex)) {
                        // skip ones already validated
                        continue;
                    }

                    //all genotypes in the overlapping true variant will be checked
                    for (int parent = 0; parent < 2; parent++) {
                        int allele = trueVariant.getAllele(parent);

                        if (allele == 0 || // reference allele
                            type != trueVariant.getType(allele) ||
                                variant.getAlt(allele) == null ||
                                trueVariant.getAlt(allele) == null) { // need type to be the same
                            continue;
                        }

                        Alt.Breakend currentBreakend = variant.getAlt(allele).getBreakend();
                        Alt.Breakend trueBreakend = trueVariant.getAlt(allele).getBreakend();
                        boolean overlap = trueVariant.getVariantInterval(allele, ignoreInsertionLength).
                                intersects(intervalForCompare, overlapRatio, wiggle);
                        boolean breakendMatch =  trueVariant.getType(allele) == VariantType.Breakend &&
                                Alt.Breakend.looseEquals(currentBreakend, trueBreakend, overlapRatio, wiggle);
                        boolean matched = trueVariant.getType(allele) == VariantType.Breakend ? breakendMatch : overlap;

                        if (matched) {
                            if (trueVariant.isHom()) {
                                homozygousMatches.add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                            } else {
                                heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                            }
                            maxTrueVarianLength = Math.max(trueVariant.maxLen(allele), maxTrueVarianLength);
                        }
                        //for homozygous variants, we only check the first allele
                        if (trueVariant.isHom())
                            break;
                    }
                }

            }

            return maxTrueVarianLength;
        }
    }

    /**
     * capable of recording multiple matched true variants
     * should be favored over {@link ResultComparator}
     */
    class MultiResultComparator {
        final chrSearchTree<ValueInterval1D<Variant>> trueVariantIntervalTree; // true variants
        final double overlapRatio;
        final int wiggle;
        final boolean ignoreInsertionLength;
        final boolean matchGenotype;

        public MultiResultComparator(chrSearchTree<ValueInterval1D<Variant>> trueVariantIntervalTree, double overlapRatio,
                                     int wiggle, boolean ignoreInsLen, boolean matchGenotype) {
            this.trueVariantIntervalTree = trueVariantIntervalTree;
            this.overlapRatio = overlapRatio;
            this.wiggle = wiggle;
            this.ignoreInsertionLength = ignoreInsLen;
            this.matchGenotype = matchGenotype;
        }

        List<DualIdx> homozygousMatches = new ArrayList<>();
        List<List<DualIdx>> heterozygousMatches = Arrays.asList(new ArrayList<DualIdx>(), new ArrayList<DualIdx>()); // matches either parent
        public List<VariantPair> findAllPairs(Variant v) {
            //boolean overlapComplex;
            // Results to store
            // this stores the indexes of the true variants matched

            return new ArrayList<VariantPair>();
        }

        /**
         * return first homozygous match (empty if no match)
         * @return
         */
        public DualIdx firstHomMatch() {
            return homozygousMatches.isEmpty() ? new DualIdx() : homozygousMatches.get(0);
        }

        /**
         * return first heterozygous match (empty if no match)
         * @return
         */
        public DualIdx firstHetMatch() {
            List<DualIdx> temp = new ArrayList<>(heterozygousMatches.get(0));
            temp.retainAll(heterozygousMatches.get(1)); //essentially get intersection
            //if there is a match in intersection, return the first one from the intersection
            if (!temp.isEmpty()) {
                return temp.get(0);
              /*
              if no match in intersection, return the first one from the larger list (the genotype
              containing more heterozygous matches).
              since ResultComparator is created for each variant, heterzygousMatches will only
              store matches for one variant against some true variants. Therefore, I think
              one of the lists in heterozygousMatches will always be zero if there is no intersection
              between them. And in such cases, we just return whatever we have in matches.

              an example, compare these two lines:
              1	993	rs35493185	C	CA	.	.	SVLEN=1	GT	1|0
              1	993	rs35493185	C	CA	.	.	SVLEN=1	GT	1|0

               */
            } else if (heterozygousMatches.stream().anyMatch(l -> !l.isEmpty())) {
                if (heterozygousMatches.get(0).size() > heterozygousMatches.get(1).size()) {
                    return heterozygousMatches.get(0).get(0);
                } else {
                    return heterozygousMatches.get(1).get(0);
                }
            }
            return new DualIdx();
        }

        /**
         * determine if there is a match regardless of genotype
         * @return DualIdx of matched variant
         */
        public DualIdx firstMatch() {
            DualIdx idx = firstHomMatch();
            if (idx.isSplitVariantValid()) {
                return idx;
            }
            idx = firstHetMatch();
            if (idx.isSplitVariantValid()) {
                return idx;
            }
            return idx;
        }

        /**
         * Only compares one allele at a time
         * - don't match variants in the bitset
         * - if match set the bitset
         *
         * @param variant       variant we want to compare
         * @param genotype      allele of the variant to compare
         * @return The maximum length of all true variants
         */
        public int compareVariant(Variant variant, int genotype) {
            return compareVariant(variant, genotype, new BitSet());
        }
        /**
         * Only compares one allele at a time
         * - don't match variants in the bitset
         * - if match set the bitset
         *
         * @param variant       variant we want to compare
         * @param genotype      allele of the variant to compare
         * @param validated BitSet that records the true variants that have already been validated
         *                  can be empty BitSet if we don't skip validated ones
         * @return The maximum length of all true variants
         */
        public int compareVariant(Variant variant, int genotype, BitSet validated) {
            //TODO: consider type to change overlap percent
            VariantType type = variant.getType(genotype);
            ChrString chr = variant.getChr();
            SimpleInterval1D intervalForCompare = variant.getVariantInterval(genotype, ignoreInsertionLength);

            int maxTrueVarianLength = 0;

            // sometimes MNPs are called as SNPs?
            if (type == VariantType.SNP) {
                // handle SNPs differently
                // require SNP content to match
                Iterable<ValueInterval1D<Variant>> overlaps = trueVariantIntervalTree.getOverlaps(chr, intervalForCompare);

                if (overlaps == null) {
                    // nothing found
                    return maxTrueVarianLength;
                }

                byte alternativeAlleleFirstBase = variant.getAlt(genotype).getSequence()[0];

                int numberOfSnpMatches = 0;
                for (ValueInterval1D<Variant> trueVariantInterval : overlaps) {
                    Variant trueVariant = trueVariantInterval.getContent();
                    boolean hasSnp = false;
                    int splitVariantIndex = trueVariant.splitVariantIndex;
                    int wholeVariantIndex = trueVariant.wholeVariantIndex;
                    overlapComplex = trueVariant.originalType == VariantOverallType.Complex;

                    if (validated.get(splitVariantIndex)) {
                        // skip ones already validated
                        continue;
                    }

                    // check genotype
                    for (int parent = 0; parent < 2; parent++) {
                        int allele = trueVariant.getAllele(parent);
                        //true variant is heterozygous, so only one allele has non-reference sequence
                        if (trueVariant.isHom() || allele > 0) {
                            if (trueVariant.getType(allele) == VariantType.SNP
                                    && variant.getPos() == trueVariant.getPos()) {
                                if (alternativeAlleleFirstBase == trueVariant.getAlt(allele).getSequence()[0]) {
                                    if (trueVariant.isHom())
                                        homozygousMatches.add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                                    else
                                        heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                                }
                                hasSnp = true;
                            }
                        }
                        if (trueVariant.isHom())
                            break;
                    }

                    if (hasSnp) {
                        numberOfSnpMatches++;
                        maxTrueVarianLength = 1;
                    }
                }

                if (numberOfSnpMatches > 1) {
                    log.info("Something strange, multiple SNP matches in true set: " + numberOfSnpMatches);
                }
            } else {
                // Non-SNPs
                SimpleInterval1D intervalForCompareWithWiggle = new SimpleInterval1D(intervalForCompare.left - wiggle, intervalForCompare.right + wiggle);
                Iterable<ValueInterval1D<Variant>> overlaps = trueVariantIntervalTree.getOverlaps(chr, intervalForCompareWithWiggle);

                if (overlaps == null) {
                    // nothing found
                    return maxTrueVarianLength;
                }

                for (ValueInterval1D<Variant> trueVariantInterval : overlaps) {
                    Variant trueVariant = trueVariantInterval.getContent();
                    int splitVariantIndex = trueVariant.splitVariantIndex;
                    int wholeVariantIndex = trueVariant.wholeVariantIndex;
                    overlapComplex = trueVariant.originalType == VariantOverallType.Complex;

                    if (validated.get(splitVariantIndex)) {
                        // skip ones already validated
                        continue;
                    }

                    //all genotypes in the overlapping true variant will be checked
                    for (int parent = 0; parent < 2; parent++) {
                        int allele = trueVariant.getAllele(parent);

                        if (allele == 0 || // reference allele
                                type != trueVariant.getType(allele) ||
                                variant.getAlt(allele) == null ||
                                trueVariant.getAlt(allele) == null) { // need type to be the same
                            continue;
                        }

                        Alt.Breakend currentBreakend = variant.getAlt(allele).getBreakend();
                        Alt.Breakend trueBreakend = trueVariant.getAlt(allele).getBreakend();
                        boolean overlap = trueVariant.getVariantInterval(allele, ignoreInsertionLength).
                                intersects(intervalForCompare, overlapRatio, wiggle);
                        boolean breakendMatch =  trueVariant.getType(allele) == VariantType.Breakend &&
                                Alt.Breakend.looseEquals(currentBreakend, trueBreakend, overlapRatio, wiggle);
                        boolean matched = trueVariant.getType(allele) == VariantType.Breakend ? breakendMatch : overlap;

                        if (matched) {
                            if (trueVariant.isHom()) {
                                homozygousMatches.add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                            } else {
                                heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                            }
                            maxTrueVarianLength = Math.max(trueVariant.maxLen(allele), maxTrueVarianLength);
                        }
                        //for homozygous variants, we only check the first allele
                        if (trueVariant.isHom())
                            break;
                    }
                }

            }

            return maxTrueVarianLength;
        }
    }
    class VariantPair implements Comparable<VariantPair> {
        @Override
        public int compareTo(VariantPair o) {
            return 0;
        }
    }

}
